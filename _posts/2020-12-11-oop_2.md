---
published: true
layout: post
title: "JAVA를 느껴보자(2)"
<!-- date:   2020-12-06 11:56:00 +0900 -->
subtitle: "- 메세징, 메서드 그리고 다형성"
categories: ['java']
background: '/img/bg-post.jpg'
sitemap :
  changefreq : daily
  priority : 1.0
---

이전 포스팅에선 JAVA의 뿌리인 추상화의 강력함에 대해 설명하였다. JAVA의 꽃인 다형성에 대하여 설명하려 했으나, 그 전에 메세징과 오퍼레이션, 메서드에 대해 설명해야 할 것 같다. 

JAVA에서 메시징은 C에서 함수호출과 비슷하다. ```메시징```의 의미는 객체가 또 다른 객체의 인터페이스를 통해 어떠한 행위를 하라고 명령하는 것으로 필요하다면 데이터를 담아서 보낼 수도 있다. 여기서 말하는 ```인터페이스```는 JAVA의 interface키워드를 말하는 것이 아니라 객체 간의 소통을 가능하게 해주는 public method를 뜻한다. *(앞으로 내 포스트에 자주 등장하니 알아 두자.)*

>왜 메시징을 보내야 할까?

 그냥 한 클래스 안에서 다 해결하면 안 되는 것인가? 물론 다들 답을 알고 있을 것이다. SOLID의 [SRP원칙]( https://ko.wikipedia.org/wiki/단일_책임_원칙)에 의해 한 클래스는 하나의 책임만 갖도록 설계해야 한다. 그렇기 때문에 자신이 못하는 것을 누군가 대신 해주 길 원할 때, 그것을 해줄 수 있는 객체에게 메시징을 하는 것이다. 덧붙이자면 이것을 책임을 위임했다 해서 ```위임```이라 하는데, 이것들에 대해서는 다음에 자세히 다루기로 하자.  
```java
dog.drink(water);	//java의 메시지 전송형태
```
메시지는 오퍼레이션명+인자, 메시지 전송(메시징)은 메시지에 수신자가 더해진 형태이다. 메시지는 명령이기 때문에 오퍼레이션명 또한 명령문으로 작성하는 것이 좋다. [오버로딩](https://ko.wikipedia.org/wiki/함수_오버로드)의 가능성이 있다면 ```drinkWater()```가 아니라 ```drink(water)``` 처럼 목적어를 빼는 것이 좋다. 인자의 타입으로 충분히 알 수 있고 이렇게 함으로써 좀더 추상적인 이름이 되어 코드의 유연성이 증가하기 때문이다. 

좀 더 범용적으로 표현하자면  *인터페이스의 오퍼레이션 명은 ```어떻게``` 수행하는지 알려주는 구체적인 이름보단 ```무엇을``` 하는지 행위만 간략히 표현하는 추상적인 이름으로 짓는 것이 좋다.*

여기서 한가지 궁금할 수도 있다. 메시지 전송과 메서드호출은 같은 것인가? 엄밀히 말하면 다르다.
[그림]
설명하기에 앞서 잠깐 말하자면 메시징을 보내는 객체를 송신객체 또는 클라이언트 객체, 받는 객체를 수신객체 또는 서버 객체라고 한다는 것을 알아두자. 자 그럼 다시 위의 그림을 보자. 클라이언트 객체가 메시지를 보내면 ```Java Runtime System```이 메시지 전송을 오퍼레이션 호출로 해석한다. 메시지를 받은 서버 객체는 오퍼레이션에 맞는 적절한 메서드를 찾아 실행한다.  즉, ```메시징```은 객체의 구체적인 메서드를 부르는 것이 아닌 인터페이스를 통해 ```추상적인 명령을 전달```하는 것이고 ```메서드```는 오퍼레이션 호출에의해 불려지는 ```구현된 코드```이다. 

이전의 추상클래스에 대한 내용을 가지고 다시 보자. 우리는 메시징과 함수호출을 구분함으로써 3가지의 큰 이득이 생긴다.
>
>1. 메시지 전송자는 수신자가 실행하는 메서드가 어떻게 실행되는지 몰>라도 된다. 단지 인터페이스의 이름만으로 무엇을 할 수 있는지 알 수 있고 명령을 내리면 된다. 
>2. 메시지 수신자는 누가 전송하는지 알 필요없고  전송받은 메시지를 올바르게 처리하기 위해 필요한 메서드를 스스로 선택할 수 있는 자율권을 얻는다. 
>3. 메시지 전송자와 수신자가 느슨하게 결합되도록 할 수 있다. 
---
 ### 메서드가 어떻게 실행되는지 모르는 것이 왜 이득인가?

우리가  사용하는 스마트폰을 생각해보자. 우리는 키를 하나하나 입력할 때마다 컴퓨터 안에서 어떤 내부로직이 실행되고 결과가 나오는지를 알아야하는가? 아니다 우리는 UI라고 하는 사용자 인터페이스를 통해 ```무엇을 할 수있는지 알 수있고 그냥 보이는 그대로 사용하면 된다. 코드를 통해 더 자세히 설명해보자. 
```java
public interface Puppy{
	public void drink(Water water);
}
public class Client{
	public void Client(Puppy puppy, Water water){
		puppy.drink(water);
	}
}
```
Client가 생성되면 전달받은 Puppy와 Water를 사용하여 drink()를 실행하는 간단한 예시이다. 

> 우리는 Puppy가 Choco인지 Berry인지 아는가? 

우리는 모른다 단지 전달받은 것은 Puppy라는 것과 Puppy의 ```계약책임```에 의해 전달된 것은 분명히 drink()라는 ```인터페이스```를 가지고 있다는 것만 알 수 있다. 물론 코드를 파헤쳐서 Client를 생성할 때 전달되는 인자를 확인할 수 있다. 하지만 굳이 그러지 않아도 우리는 오퍼레이션명과 인자를 통해  ```무엇을``` 할지 알 수있다.  drink라는 명령을 ```어떻게`` 수행하는지는 알 필요 없다. 그저 사용하면 우리는 어떤 일이 벌어질지 예상 할 수 있다.  API문서까지 있다면 예상은 확신으로 바뀐다.

우리가 흔히 사용하는 ArrayList로 예시를 더 들어보자.  우리는 남이 만들어 놓은 ArrayList의 add() 내부 로직이 어떻게 수행되는 지 모른다. 하지만 우리는 add가 원소를 배열에 추가해 준다는 것을 알고 그냥 사용하면 된다. 

---
###  전송받은 메시지를 올바르게 처리하기 위해 필요한 메서드를 스스로 선택할 수 있는 자율권을 얻는다?
```java
public interface Puppy{
	public void drink(Water water);
}
public class Client{
	public void Client(Puppy puppy, Water water){
		puppy.drink(water);
	}
}
```
코드를 보면서 생각해보자. 우리는 puppy가 Choco인지 Berry인지 모르지만 분명히 drink()를 할 수 있다는 것은 안다. 하지만 Choco와 Berry가 drink()를 ```어떻게```수행하는지는 모른다. RuntimeSystem은 Choco와 Berry에게 drink(water)메시지에 맞는 메서드를 스스로 선택할 수 있는 자율권을 

이때, Choco와 Berry는 같은 행위를 할수도 있지만 다른 행위를 할 수도 있다.  이것이 ```다형성```이다.

너무 간단한가? 더 자세히 설명해보자면, 우리가 1번을 누르면 Client에 Choco가 주입되고 2번을 누르면 Berry가 주입된다고 가정하자. puppy.drink(water)라는 메시징은 컴파일시에 고정이되고 변하지 않는다. 하지만 Runtime에 우리가 누르는 버튼에 따라 주입되는 Puppy가 바뀌고 결과 또한 다르게 나올 것이다. 

신기하지 않는가? 코드는 변하지 않는데 기능이 변한다니...우리가 키보드 자판의 같은 키를 누르는데 앱마다 다른 기능을 하는 것도 다형성이다.  어떻게 이런 것이 가능할 까? 바로 구현의 책임을 Puppy가아니라 Choco와 Berry에게 주었고 그럼으로써 Choco와 Berry

즉, ```다형성```이란 ***같은 메시징에 대하여 서로다른 처리를 할 수있는 것을 말한다***. 코드의 관점으로 말하자면 한가지의 ***코드로 여러 기능을 할 수 있는 것을 말한다.***







